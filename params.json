{"name":"CacheCache","body":"# Installation\r\n\r\nThe easiest way to install CacheCache is using [Composer](https://github.com/composer/composer)\r\nwith the following requirement:\r\n\r\n    {\r\n        \"require\": {\r\n            \"maximebf/cachecache\": \">=0.1.0\"\r\n        }\r\n    }\r\n\r\nAlternatively, you can [download the archive](https://github.com/maximebf/CacheCache/zipball/master) \r\nand add the lib/ folder to PHP's include path:\r\n\r\n    set_include_path('/path/to/lib' . PATH_SEPARATOR . get_include_path());\r\n\r\nCacheCache does not provide an autoloader but follows the [PSR-0 convention](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md).  \r\nYou can use the following snippet to autoload CacheCache classes:\r\n\r\n    spl_autoload_register(function($className) {\r\n        if (substr($className, 0, 10) === 'CacheCache') {\r\n            $filename = str_replace('\\\\', DIRECTORY_SEPARATOR, trim($className, '\\\\')) . '.php';\r\n            require_once $filename;\r\n        }\r\n    });\r\n\r\n# Usage\r\n\r\n## The CacheManager\r\n\r\n`CacheManager` is a static class that can be used to initialize and store multiple instances\r\nof Cache objects.\r\n\r\nStoring and accessing Cache objects:\r\n\r\n    $cache = new Cache(new Backends\\Memory());\r\n    CacheManager::set('mycache', $cache);\r\n\r\n    // ...\r\n\r\n    $cache = CacheManager::get('mycache');\r\n\r\nCache objects can be created and initialized using an array with the `factory()` method. \r\nThe following options can be defined:\r\n\r\n - backend: backend class name or Backend instance\r\n - backend_args: an array of constructor arguments for the backend\r\n - namespace\r\n - ttl\r\n - variation\r\n\r\nExample:\r\n\r\n    $cache = CacheManager::factory(array(\r\n        'backend' => 'CacheCache\\Backends\\Memcache',\r\n        'backend_args' => array(array(\r\n            'host' => 'localhost',\r\n            'port' => 11211\r\n        ))\r\n    ));\r\n\r\nFinally, multiple Cache objects can be created at the same time using the `setup()` method. It takes\r\nas first parameter an array of key/value pairs where keys will be used as the cache name to be used\r\nwith the `get()` method and values are an array to be used with `factory()`. The second argument can\r\nbe a `Monolog\\Logger` instance to enable logging.\r\n\r\n    CacheManager::setup(array(\r\n        'array' => 'CacheCache\\Backends\\Memory',\r\n        'memcache' => array(\r\n            'backend' => 'CacheCache\\Backends\\Memcache',\r\n            'backend_args' => array(array(\r\n                'host' => 'localhost',\r\n                'port' => 11211\r\n            ))\r\n        )\r\n    ));\r\n\r\n    $cache = CacheManager::get('array');\r\n\r\n## Simple usage\r\n\r\nCache (and backends) objects expose the following methods to interact with the data:\r\n\r\n - `exists($id)`\r\n - `get($id, $default = null)`\r\n - `set($id, $value, $ttl = null)`\r\n - `add($id, $value, $ttl = null)`\r\n - `delete($id)`\r\n\r\nThe `add()` method won't replace any existing value whereas `set()` will do.\r\n`$ttl` stands for Time To Live and will be the lifetime in seconds of the entry.\r\n\r\nIf `get()` is used to retreive a non existing `$id`, the `$default` value is returned instead.\r\n\r\nExamples:\r\n\r\n    $cache->set('foo', 'bar');\r\n    $cache->exists('foo');\r\n    $cache->get('foo');\r\n    $cache->delete('foo');\r\n\r\n    $cache->add('foo', 'bar', 10);\r\n    $cache->exists('foo'); // true\r\n    sleep(11);\r\n    $cache->exists('foo'); // false\r\n\r\n    if (($foo = $cache->get('foo')) === null) {\r\n        $foo = 'bar';\r\n        $cache->set('foo', $foo);\r\n    }\r\n\r\nTo avoid manually testing entries for their existence you can use the `getset()` method:\r\n\r\n    $foo = $cache->getset('foo', function() {\r\n        return 'bar';\r\n    });\r\n\r\nIn this example, the closure is called only when \"foo\" does not exist. Another way of \r\ndoing a similar operation without the use of closures is using the `load()` and `save()` methods.\r\n\r\n    if (!($foo = $cache->load('foo'))) {\r\n        $foo = 'bar';\r\n        $cache->save($foo);\r\n    }\r\n\r\n`load()` and `save()` calls can be nested. A currently running operation (after performing a `load()`)\r\ncan be cancelled using `cancel()`.\r\n\r\n    if (!($foo = $cache->load('foo'))) {\r\n        try {\r\n            $foo = 'bar';\r\n            $cache->save($foo);\r\n        } catch (Exception $e) {\r\n            $cache->cancel();\r\n            $foo = 'default value';\r\n        }\r\n    }\r\n\r\n## Caching function calls\r\n\r\nThe `call()` function can be used to cache function calls. It behaves the same way as\r\n`call_user_func_array()`. The cache id is generated using the function name and the serialized arguments.\r\n\r\n    function do_heavy_stuff($arg) {\r\n        sleep(1);\r\n        return $arg;\r\n    }\r\n\r\n    echo $cache->call('do_heavy_stuff', array('foo')); // sleeps 1 sec\r\n    echo $cache->call('do_heavy_stuff', array('bar')); // sleeps 1 sec\r\n    echo $cache->call('do_heavy_stuff', array('foo')); // won't sleep\r\n\r\n## Caching object methods\r\n\r\nObject methods can be cached by wrapping an object into a special proxy class. The object can be used\r\nas usual but all calls to its methods will be cached. The cache id for each method is computed using \r\nthe method name, the serialized arguments and the serialized public properties of the object. The `wrap()`\r\nmethod automatically creates a namespace for all cache ids of this object which is, by default, named after the class.\r\n\r\n    class MyClass {\r\n        public function doHeavyStuff($arg) {\r\n            sleep(1);\r\n            return $arg;\r\n        }\r\n    }\r\n\r\n    $obj = $cache->wrap(new MyClass());\r\n    echo $obj->doHeavyStuff('foo'); // sleeps 1 sec\r\n    echo $obj->doHeavyStuff('foo'); // won't sleep\r\n\r\n## Capturing content\r\n\r\nCacheCache provides multiple ways to capture echoed content. The easiest one works the same way as `load()` and `save()`\r\nbut uses `start()` and `end()`.\r\n\r\n    if (!$cache->start('foo')) {\r\n        echo 'bar';\r\n        $cache->end();\r\n    }\r\n\r\n`cancel()` can also be used to cancel a call to `start()`.\r\n\r\nThe output of a function can also be captured using the `capture()` method which works the same way as `getset()`.\r\n\r\n    $foo = $cache->capture('foo', function() {\r\n        echo 'bar';\r\n    });\r\n\r\nFinally, the whole content of a page can be captured using `capturePage()`. It must be called before any\r\ncontent has been outputed.\r\n\r\n    $cache->capturePage();\r\n    \r\nBy default, the cache id will be computed from the `REQUEST_URI` and the `$_REQUEST` array and the method \r\ncalls `exit()` if there is a hit.\r\n\r\n## Multiple operations at once and pipelines\r\n\r\nMulti get and set operations are available in a similar fashion as with the libmemcached pecl extension.\r\n\r\n    $cache->setMulti(array(\r\n        'foo' => 'bar',\r\n        'bar' => 'foo'\r\n    ));\r\n    \r\n    $r = $cache->getMulti(array('foo', 'bar'));\r\n    // $r = array('bar', 'foo');\r\n\r\nCacheCache also introduces the concept of pipelines inspired by Predis. A pipeline is an object that\r\nstack operations and executes them all at the same time. Not all backends have native support for pipelines\r\n(only redis for the moment). A simple pipeline implementation based on `setMulti()` and `getMulti()` is provided\r\nfor the other ones.\r\n\r\n    $r = $cache->pipeline(function($pipe) {\r\n        $pipe->set('foo', 'bar');\r\n        $pipe->set('bar', 'foo');\r\n        $pipe->get('foo');\r\n        $pipe->get('bar');\r\n    });\r\n\r\n## Namespaces\r\n\r\nNamespaces allow you to better organize cache ids. A cache namespace is simply a new Cache object bound to\r\na specific namespace. To create a subnamespace of the current one, use the `ns()` method.\r\n\r\n    $cache->set('a', 'b'); // id = a\r\n\r\n    $foo = $cache->ns('foo');\r\n    $foo->set('a', 'c'); // id = foo:a\r\n\r\n## Multiple caches\r\n\r\nMultiple backends can be chained together using the `MultiCache` class. When a value is retreived (get or exists)\r\nit will first try in the first backend then in the second if it misses, then the third, etc...  \r\nWhen a key/value pair is modified (insert, add or delete), the operation will be performed on all backends.\r\n\r\n    $cache = new MultiCache(array($backend1, $backend2));\r\n\r\nNOTE: Cache objects are themselves backends!\r\n\r\n## Logging\r\n\r\nBackend usage can be logged using the `LoggingBackend` class which requires a `Monolog\\Logger` instance. \r\n\r\n    $logger = new Monolog\\Logger();\r\n    $backend = new LoggingBackend(new Backends\\Memory(), $logger);\r\n    $cache = new Cache($backend);","tagline":"Caching library for PHP 5.3+","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}